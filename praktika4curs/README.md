## работа с проектом
1) Из корня репозитория выполнить: docker-compose up --build
2) Открыть в браузере: http://localhost:8080 или Swagger: http://localhost:8000/docs
3) Остановка проекта: docker-compose down

## Технологии
Frontend: Vue
Backend: FastAPI, SQLAlchemy
Database: PostgreSQL
Контейнеризация: Docker, docker-compose

## Функциональность
## Frontend (Vue):
### Проекты:
отображение списка проектов с указанием времени создания
создание проекта по названию
удаление проекта
### проект:
просмотр изображений выбранного проекта
загрузка изображений в проект через кнопку выбора файлов
загрузка изображений в проект через drag-and-drop
предпросмотр изображений миниатюрами
удаление отдельных изображений
просмотр выбранного изображения на отдельной странице
### изображение:
рисование прямоугольников box мышью по изображению
после завершения рисования открывается форма выбора/ввода класса
каждый бокс хранит координаты (x, y, w, h), класс и идентификатор
редактирование класса и удаление бокса кликом по боксу
показывает класс при наведении на бокс
выпадающий список ранее использованных классов
имитация “ML Predict” подгрузка фейковых боксов от backend
масштабирование zoom изображения от x1 до x3

## Backend (FastAPI + PostgreSQL)
### Health:
GET /health — проверка состояния сервиса
### Проекты:
POST /projects — создать проект
GET /projects — получить список проектов
DELETE /projects/{id} — удалить проект и все связанные изображения
### Изображения:
POST /projects/{id}/images — загрузить одно или несколько изображений в проект
GET /projects/{id}/images — получить метаданные изображений и публичные ссылки
DELETE /images/{image_id} — удалить конкретное изображение
### Аннотации:
GET /images/{image_id}/annotations — получить box изображения
POST /images/{image_id}/annotations — сохранить аннотации
POST /predict/{image_id} — сгенерировать и сохранить 1–3 фейковые аннотации для изображения (классы вида ML_obj_(1-10))
### Публичная раздача файлов:
GET /uploads/<storage_name> — доступ к загруженным изображениям по публичному URL

## Как перейти на S3/MinIO (план замены локального хранилища)
В проекте выделен слой хранения файлов backend/app/storage.py.
Сейчас он реализует локальное сохранение на диск:
save_upload_file(upload_dir, file) -> storage_name
delete_file(upload_dir, storage_name)
Чтобы перейти на MinIO/S3:
Заменить реализацию storage.py на работу с S3 API (boto3 / minio client).
Вместо storage_name хранить в БД ключ объекта (например bucket/key).
url в GET /projects/{id}/images формировать как публичный URL бакета.

Архитектура API и таблиц при этом сохраняется: меняется только слой хранения файлов.




Вот самые нужные “комбинации символов” для README.md (Markdown). Примеры даю так, как ты будешь писать в файле.

Заголовки

# Заголовок 1

## Заголовок 2

### Заголовок 3

Жирный / курсив / зачёркнутый
**жирный**
*курсив*  (или *курсив*)
***жирный+курсив***
~~зачёркнутый~~

Абзацы и переносы строки

* Пустая строка = новый абзац.
* Просто Enter обычно не делает перенос (в зависимости от рендера).
* “Жёсткий” перенос строки: поставить 2 пробела в конце строки и Enter
  Пример:
  Строка 1␠␠
  Строка 2

Списки
Маркированный:

* пункт
* пункт

  * подпункт (2 пробела или таб)

Нумерованный:

1. шаг
2. шаг

   1. подпункт

Ссылки
[Текст ссылки](https://example.com)

Картинки
![alt-текст](path/to/image.png)
(можно ссылку вместо пути)

Код
Инлайн-код: `npm install`

Блок кода:

```bash
docker-compose up --build
```

Цитата

> Это цитата

## Разделитель (горизонтальная линия)

(или ***)

Таблицы

| Колонка 1 | Колонка 2 |
| --------- | --------- |
| значение  | значение  |

Чекбоксы

* [ ] не сделано
* [x] сделано

Спойлер (на GitHub работает через HTML)

<details>
  <summary>Нажми, чтобы раскрыть</summary>

Текст внутри.

</details>

Экранирование спецсимволов
Если нужно показать символ как текст, ставь обратный слэш:
*не курсив*
# не заголовок

Если хочешь — кинь свой README (как текст), и я быстро приведу его к аккуратному Markdown-формату под GitHub (без лишней “красоты”, чисто читабельно).
